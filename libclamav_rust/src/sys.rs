/* automatically generated by rust-bindgen 0.59.2 */

#![allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]

pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __time_t = ::std::os::raw::c_long;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type off_t = __off_t;
pub type ssize_t = __ssize_t;
pub type time_t = __time_t;
pub type size_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
pub const cl_error_t_CL_CLEAN: cl_error_t = 0;
pub const cl_error_t_CL_SUCCESS: cl_error_t = 0;
pub const cl_error_t_CL_VIRUS: cl_error_t = 1;
pub const cl_error_t_CL_ENULLARG: cl_error_t = 2;
pub const cl_error_t_CL_EARG: cl_error_t = 3;
pub const cl_error_t_CL_EMALFDB: cl_error_t = 4;
pub const cl_error_t_CL_ECVD: cl_error_t = 5;
pub const cl_error_t_CL_EVERIFY: cl_error_t = 6;
pub const cl_error_t_CL_EUNPACK: cl_error_t = 7;
pub const cl_error_t_CL_EOPEN: cl_error_t = 8;
pub const cl_error_t_CL_ECREAT: cl_error_t = 9;
pub const cl_error_t_CL_EUNLINK: cl_error_t = 10;
pub const cl_error_t_CL_ESTAT: cl_error_t = 11;
pub const cl_error_t_CL_EREAD: cl_error_t = 12;
pub const cl_error_t_CL_ESEEK: cl_error_t = 13;
pub const cl_error_t_CL_EWRITE: cl_error_t = 14;
pub const cl_error_t_CL_EDUP: cl_error_t = 15;
pub const cl_error_t_CL_EACCES: cl_error_t = 16;
pub const cl_error_t_CL_ETMPFILE: cl_error_t = 17;
pub const cl_error_t_CL_ETMPDIR: cl_error_t = 18;
pub const cl_error_t_CL_EMAP: cl_error_t = 19;
pub const cl_error_t_CL_EMEM: cl_error_t = 20;
pub const cl_error_t_CL_ETIMEOUT: cl_error_t = 21;
pub const cl_error_t_CL_BREAK: cl_error_t = 22;
pub const cl_error_t_CL_EMAXREC: cl_error_t = 23;
pub const cl_error_t_CL_EMAXSIZE: cl_error_t = 24;
pub const cl_error_t_CL_EMAXFILES: cl_error_t = 25;
pub const cl_error_t_CL_EFORMAT: cl_error_t = 26;
pub const cl_error_t_CL_EPARSE: cl_error_t = 27;
pub const cl_error_t_CL_EBYTECODE: cl_error_t = 28;
pub const cl_error_t_CL_EBYTECODE_TESTFAIL: cl_error_t = 29;
pub const cl_error_t_CL_ELOCK: cl_error_t = 30;
pub const cl_error_t_CL_EBUSY: cl_error_t = 31;
pub const cl_error_t_CL_ESTATE: cl_error_t = 32;
pub const cl_error_t_CL_VERIFIED: cl_error_t = 33;
pub const cl_error_t_CL_ERROR: cl_error_t = 34;
pub const cl_error_t_CL_ELAST_ERROR: cl_error_t = 35;
pub type cl_error_t = ::std::os::raw::c_uint;
#[doc = " scan options"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cl_scan_options {
    pub general: u32,
    pub parse: u32,
    pub heuristic: u32,
    pub mail: u32,
    pub dev: u32,
}
pub const bytecode_security_CL_BYTECODE_TRUST_ALL: bytecode_security = 0;
pub const bytecode_security_CL_BYTECODE_TRUST_SIGNED: bytecode_security = 1;
pub const bytecode_security_CL_BYTECODE_TRUST_NOTHING: bytecode_security = 2;
pub type bytecode_security = ::std::os::raw::c_uint;
pub const bytecode_mode_CL_BYTECODE_MODE_AUTO: bytecode_mode = 0;
pub const bytecode_mode_CL_BYTECODE_MODE_JIT: bytecode_mode = 1;
pub const bytecode_mode_CL_BYTECODE_MODE_INTERPRETER: bytecode_mode = 2;
pub const bytecode_mode_CL_BYTECODE_MODE_TEST: bytecode_mode = 3;
pub const bytecode_mode_CL_BYTECODE_MODE_OFF: bytecode_mode = 4;
pub type bytecode_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_section_hash {
    pub md5: [::std::os::raw::c_uchar; 16usize],
    pub len: size_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_stats_sections {
    pub nsections: size_t,
    pub sections: *mut cli_section_hash,
}
pub type stats_section_t = cli_stats_sections;
#[doc = " @brief Pre-cache callback."]
#[doc = ""]
#[doc = " Called for each processed file (both the entry level - AKA 'outer' - file and"]
#[doc = " inner files - those generated when processing archive and container files), before"]
#[doc = " the actual scanning takes place."]
#[doc = ""]
#[doc = " @param fd        File descriptor which is about to be scanned."]
#[doc = " @param type      File type detected via magic - i.e. NOT on the fly - (e.g. \"CL_TYPE_MSEXE\")."]
#[doc = " @param context   Opaque application provided data."]
#[doc = " @return          CL_CLEAN = File is scanned."]
#[doc = " @return          CL_BREAK = Allowed by callback - file is skipped and marked as clean."]
#[doc = " @return          CL_VIRUS = Blocked by callback - file is skipped and marked as infected."]
pub type clcb_pre_cache = ::std::option::Option<
    unsafe extern "C" fn(
        fd: ::std::os::raw::c_int,
        type_: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t,
>;
#[doc = " @brief Pre-scan callback."]
#[doc = ""]
#[doc = " Called for each NEW file (inner and outer) before the scanning takes place. This is"]
#[doc = " roughly the the same as clcb_before_cache, but it is affected by clean file caching."]
#[doc = " This means that it won't be called if a clean cached file (inner or outer) is"]
#[doc = " scanned a second time."]
#[doc = ""]
#[doc = " @param fd        File descriptor which is about to be scanned."]
#[doc = " @param type      File type detected via magic - i.e. NOT on the fly - (e.g. \"CL_TYPE_MSEXE\")."]
#[doc = " @param context   Opaque application provided data."]
#[doc = " @return          CL_CLEAN = File is scanned."]
#[doc = " @return          CL_BREAK = Allowed by callback - file is skipped and marked as clean."]
#[doc = " @return          CL_VIRUS = Blocked by callback - file is skipped and marked as infected."]
pub type clcb_pre_scan = ::std::option::Option<
    unsafe extern "C" fn(
        fd: ::std::os::raw::c_int,
        type_: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t,
>;
#[doc = " @brief Post-scan callback."]
#[doc = ""]
#[doc = " Called for each processed file (inner and outer), after the scanning is complete."]
#[doc = " In all-match mode, the virname will be one of the matches, but there is no"]
#[doc = " guarantee in which order the matches will occur, thus the final virname may"]
#[doc = " be any one of the matches."]
#[doc = ""]
#[doc = " @param fd        File descriptor which was scanned."]
#[doc = " @param result    The scan result for the file."]
#[doc = " @param virname   A signature name if there was one or more matches."]
#[doc = " @param context   Opaque application provided data."]
#[doc = " @return          Scan result is not overridden."]
#[doc = " @return          CL_BREAK = Allowed by callback - scan result is set to CL_CLEAN."]
#[doc = " @return          Blocked by callback - scan result is set to CL_VIRUS."]
pub type clcb_post_scan = ::std::option::Option<
    unsafe extern "C" fn(
        fd: ::std::os::raw::c_int,
        result: ::std::os::raw::c_int,
        virname: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t,
>;
#[doc = " @brief Virus-found callback."]
#[doc = ""]
#[doc = " Called for each signature match."]
#[doc = " If all-match is enabled, clcb_virus_found() may be called multiple times per"]
#[doc = " scan."]
#[doc = ""]
#[doc = " In addition, clcb_virus_found() does not have a return value and thus."]
#[doc = " can not be used to ignore the match."]
#[doc = ""]
#[doc = " @param fd        File descriptor which was scanned."]
#[doc = " @param virname   Virus name."]
#[doc = " @param context   Opaque application provided data."]
pub type clcb_virus_found = ::std::option::Option<
    unsafe extern "C" fn(
        fd: ::std::os::raw::c_int,
        virname: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief Signature-load callback."]
#[doc = ""]
#[doc = " May be used to ignore signatures at database load time."]
#[doc = ""]
#[doc = " WARNING: Some signatures (notably ldb, cbc) can be dependent upon other signatures."]
#[doc = "          Failure to preserve dependency chains will result in database loading failure."]
#[doc = "          It is the implementor's responsibility to guarantee consistency."]
#[doc = ""]
#[doc = " @param type      The signature type (e.g. \"db\", \"ndb\", \"mdb\", etc.)"]
#[doc = " @param name      Signature name."]
#[doc = " @param custom    The signature is official (custom == 0) or custom (custom != 0)"]
#[doc = " @param context   Opaque application provided data"]
#[doc = " @return          0 to load the current signature."]
#[doc = " @return          Non-0 to skip the current signature."]
pub type clcb_sigload = ::std::option::Option<
    unsafe extern "C" fn(
        type_: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        custom: ::std::os::raw::c_uint,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @brief Progress callback for sig-load, engine-compile, and engine-free."]
#[doc = ""]
#[doc = " Progress is complete when total_items == now_completed."]
#[doc = ""]
#[doc = " Note: The callback should return CL_SUCCESS. We reserve the right to have it"]
#[doc = "       cancel the operation in the future if you return something else..."]
#[doc = "       ... but for now, the return value will be ignored."]
#[doc = ""]
#[doc = " @param total_items   Total number of items"]
#[doc = " @param now_completed Number of items completed"]
#[doc = " @param context       Opaque application provided data"]
#[doc = " @return cl_error_t   reserved for future use"]
pub type clcb_progress = ::std::option::Option<
    unsafe extern "C" fn(
        total_items: size_t,
        now_completed: size_t,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t,
>;
#[doc = " @brief LibClamAV hash stats callback."]
#[doc = ""]
#[doc = " Callback that provides the hash of a scanned sample if a signature alerted."]
#[doc = " Provides a mechanism to record detection statistics."]
#[doc = ""]
#[doc = " @param fd        File descriptor if available, else -1."]
#[doc = " @param size      Sample size"]
#[doc = " @param md5       Sample md5 hash"]
#[doc = " @param virname   Signature name that the sample matched against"]
#[doc = " @param context   Opaque application provided data"]
pub type clcb_hash = ::std::option::Option<
    unsafe extern "C" fn(
        fd: ::std::os::raw::c_int,
        size: ::std::os::raw::c_ulonglong,
        md5: *const ::std::os::raw::c_uchar,
        virname: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief Archive meta matching callback function."]
#[doc = ""]
#[doc = " May be used to block archive/container samples based on archive metadata."]
#[doc = " Function is invoked multiple times per archive. Typically once per contained file."]
#[doc = ""]
#[doc = " Note: Used by the --archive-verbose clamscan option. Overriding this will alter"]
#[doc = " the output from --archive-verbose."]
#[doc = ""]
#[doc = " @param container_type    String name of type (CL_TYPE)."]
#[doc = " @param fsize_container   Sample size"]
#[doc = " @param filename          Filename associated with the data in archive."]
#[doc = " @param fsize_real        Size of file after decompression (according to the archive)."]
#[doc = " @param is_encrypted      Boolean non-zero if the contained file is encrypted."]
#[doc = " @param filepos_container File index in container."]
#[doc = " @param context           Opaque application provided data."]
#[doc = " @return                  CL_VIRUS to block (alert on)"]
#[doc = " @return                  CL_CLEAN to continue scanning"]
pub type clcb_meta = ::std::option::Option<
    unsafe extern "C" fn(
        container_type: *const ::std::os::raw::c_char,
        fsize_container: ::std::os::raw::c_ulong,
        filename: *const ::std::os::raw::c_char,
        fsize_real: ::std::os::raw::c_ulong,
        is_encrypted: ::std::os::raw::c_int,
        filepos_container: ::std::os::raw::c_uint,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t,
>;
#[doc = " @brief File properties callback function."]
#[doc = ""]
#[doc = " Invoked after a scan the CL_SCAN_GENERAL_COLLECT_METADATA general scan option"]
#[doc = " is enabled and libclamav was built with json support."]
#[doc = ""]
#[doc = " @param j_propstr File properties/metadata in a JSON encoded string."]
#[doc = " @param rc        The cl_error_t return code from the scan."]
#[doc = " @param cbdata    Opaque application provided data."]
pub type clcb_file_props = ::std::option::Option<
    unsafe extern "C" fn(
        j_propstr: *const ::std::os::raw::c_char,
        rc: ::std::os::raw::c_int,
        cbdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @brief Add sample metadata to the statistics for a sample that matched on a signature."]
#[doc = ""]
#[doc = " @param virname   Name of the signature that matched."]
#[doc = " @param md5       Sample hash."]
#[doc = " @param size      Sample size."]
#[doc = " @param sections  PE section data, if applicable."]
#[doc = " @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_add_sample = ::std::option::Option<
    unsafe extern "C" fn(
        virname: *const ::std::os::raw::c_char,
        md5: *const ::std::os::raw::c_uchar,
        size: size_t,
        sections: *mut stats_section_t,
        cbdata: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief Remove a specific sample from the statistics report."]
#[doc = ""]
#[doc = " @param virname   Name of the signature that matched."]
#[doc = " @param md5       Sample hash."]
#[doc = " @param size      Sample size."]
#[doc = " @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_remove_sample = ::std::option::Option<
    unsafe extern "C" fn(
        virname: *const ::std::os::raw::c_char,
        md5: *const ::std::os::raw::c_uchar,
        size: size_t,
        cbdata: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief Decrement the hit count listed in the statistics report for a specific sample."]
#[doc = ""]
#[doc = " @param virname   Name of the signature that matched."]
#[doc = " @param md5       Sample hash."]
#[doc = " @param size      Sample size."]
#[doc = " @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_decrement_count = ::std::option::Option<
    unsafe extern "C" fn(
        virname: *const ::std::os::raw::c_char,
        md5: *const ::std::os::raw::c_uchar,
        size: size_t,
        cbdata: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief Function to submit a statistics report."]
#[doc = ""]
#[doc = " @param engine    The initialized scanning engine."]
#[doc = " @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_submit = ::std::option::Option<
    unsafe extern "C" fn(engine: *mut cl_engine, cbdata: *mut ::std::os::raw::c_void),
>;
#[doc = " @brief Function to flush/free the statistics report data."]
#[doc = ""]
#[doc = " @param engine    The initialized scanning engine."]
#[doc = " @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_flush = ::std::option::Option<
    unsafe extern "C" fn(engine: *mut cl_engine, cbdata: *mut ::std::os::raw::c_void),
>;
#[doc = " @brief Function to get the number of samples listed in the statistics report."]
#[doc = ""]
#[doc = " @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_get_num =
    ::std::option::Option<unsafe extern "C" fn(cbdata: *mut ::std::os::raw::c_void) -> size_t>;
#[doc = " @brief Function to get the size of memory used to store the statistics report."]
#[doc = ""]
#[doc = " @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_get_size =
    ::std::option::Option<unsafe extern "C" fn(cbdata: *mut ::std::os::raw::c_void) -> size_t>;
#[doc = " @brief Function to get the machine's unique host ID."]
#[doc = ""]
#[doc = " @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_get_hostid = ::std::option::Option<
    unsafe extern "C" fn(cbdata: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_char,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cl_cvd {
    pub time: *mut ::std::os::raw::c_char,
    pub version: ::std::os::raw::c_uint,
    pub sigs: ::std::os::raw::c_uint,
    pub fl: ::std::os::raw::c_uint,
    pub md5: *mut ::std::os::raw::c_char,
    pub dsig: *mut ::std::os::raw::c_char,
    pub builder: *mut ::std::os::raw::c_char,
    pub stime: ::std::os::raw::c_uint,
}
pub type cl_fmap_t = cl_fmap;
#[doc = " @brief Read callback function type."]
#[doc = ""]
#[doc = " A callback function pointer type for reading data from a cl_fmap_t that uses"]
#[doc = " reads data from a handle interface."]
#[doc = ""]
#[doc = " Read 'count' bytes starting at 'offset' into the buffer 'buf'"]
#[doc = ""]
#[doc = " Thread safety: It is guaranteed that only one callback is executing for a"]
#[doc = " specific handle at any time, but there might be multiple callbacks executing"]
#[doc = " for different handle at the same time."]
#[doc = ""]
#[doc = " @param handle    The handle passed to cl_fmap_open_handle, its meaning is up"]
#[doc = "                  to the callback's implementation"]
#[doc = " @param buf       A buffer to read data into, must be at least offset + count"]
#[doc = "                  bytes in size."]
#[doc = " @param count     The number of bytes to read."]
#[doc = " @param offset    The the offset into buf to read the data to. If successful,"]
#[doc = "                  the number of bytes actually read is returned. Upon reading"]
#[doc = "                  end-of-file, zero is returned. Otherwise, a -1 is returned"]
#[doc = "                  and the global variable errno is set to indicate the error."]
pub type clcb_pread = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut ::std::os::raw::c_void,
        buf: *mut ::std::os::raw::c_void,
        count: size_t,
        offset: off_t,
    ) -> off_t,
>;
pub type fmap_t = cl_fmap_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cl_fmap {
    pub handle: *mut ::std::os::raw::c_void,
    pub pread_cb: clcb_pread,
    pub data: *const ::std::os::raw::c_void,
    pub mtime: time_t,
    pub pages: u64,
    pub pgsz: u64,
    pub paged: u64,
    pub aging: u16,
    pub dont_cache_flag: u16,
    #[doc = " indicates if we should not cache scan results for this fmap. Used if limits exceeded"]
    pub handle_is_fd: u16,
    #[doc = " non-zero if map->handle is an fd."]
    pub offset: size_t,
    #[doc = " file offset representing start of original fmap, if the fmap created reading from a file starting at offset other than 0"]
    pub nested_offset: size_t,
    #[doc = " offset from start of original fmap (data) for nested scan. 0 for orig fmap."]
    pub real_len: size_t,
    #[doc = " len from start of original fmap (data) to end of current (possibly nested) map."]
    pub len: size_t,
    #[doc = " length of data from nested_offset, accessible via current fmap"]
    pub unmap: ::std::option::Option<unsafe extern "C" fn(arg1: *mut fmap_t)>,
    pub need: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fmap_t,
            at: size_t,
            len: size_t,
            lock: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub need_offstr: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fmap_t,
            at: size_t,
            len_hint: size_t,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub gets: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fmap_t,
            dst: *mut ::std::os::raw::c_char,
            at: *mut size_t,
            max_len: size_t,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub unneed_off:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut fmap_t, at: size_t, len: size_t)>,
    pub have_maphash: bool,
    pub maphash: [::std::os::raw::c_uchar; 16usize],
    pub bitmap: *mut u64,
    pub name: *mut ::std::os::raw::c_char,
}
pub const cli_file_CL_TYPE_ANY: cli_file = 0;
pub const cli_file_CL_TYPE_TEXT_ASCII: cli_file = 500;
pub const cli_file_CL_TYPE_TEXT_UTF8: cli_file = 501;
pub const cli_file_CL_TYPE_TEXT_UTF16LE: cli_file = 502;
pub const cli_file_CL_TYPE_TEXT_UTF16BE: cli_file = 503;
pub const cli_file_CL_TYPE_BINARY_DATA: cli_file = 504;
pub const cli_file_CL_TYPE_ERROR: cli_file = 505;
pub const cli_file_CL_TYPE_MSEXE: cli_file = 506;
pub const cli_file_CL_TYPE_ELF: cli_file = 507;
pub const cli_file_CL_TYPE_MACHO: cli_file = 508;
pub const cli_file_CL_TYPE_MACHO_UNIBIN: cli_file = 509;
pub const cli_file_CL_TYPE_POSIX_TAR: cli_file = 510;
pub const cli_file_CL_TYPE_OLD_TAR: cli_file = 511;
pub const cli_file_CL_TYPE_CPIO_OLD: cli_file = 512;
pub const cli_file_CL_TYPE_CPIO_ODC: cli_file = 513;
pub const cli_file_CL_TYPE_CPIO_NEWC: cli_file = 514;
pub const cli_file_CL_TYPE_CPIO_CRC: cli_file = 515;
pub const cli_file_CL_TYPE_GZ: cli_file = 516;
pub const cli_file_CL_TYPE_ZIP: cli_file = 517;
pub const cli_file_CL_TYPE_BZ: cli_file = 518;
pub const cli_file_CL_TYPE_RAR: cli_file = 519;
pub const cli_file_CL_TYPE_ARJ: cli_file = 520;
pub const cli_file_CL_TYPE_MSSZDD: cli_file = 521;
pub const cli_file_CL_TYPE_MSOLE2: cli_file = 522;
pub const cli_file_CL_TYPE_MSCAB: cli_file = 523;
pub const cli_file_CL_TYPE_MSCHM: cli_file = 524;
pub const cli_file_CL_TYPE_SIS: cli_file = 525;
pub const cli_file_CL_TYPE_SCRENC: cli_file = 526;
pub const cli_file_CL_TYPE_GRAPHICS: cli_file = 527;
pub const cli_file_CL_TYPE_GIF: cli_file = 528;
pub const cli_file_CL_TYPE_PNG: cli_file = 529;
pub const cli_file_CL_TYPE_JPEG: cli_file = 530;
pub const cli_file_CL_TYPE_TIFF: cli_file = 531;
pub const cli_file_CL_TYPE_RIFF: cli_file = 532;
pub const cli_file_CL_TYPE_BINHEX: cli_file = 533;
pub const cli_file_CL_TYPE_TNEF: cli_file = 534;
pub const cli_file_CL_TYPE_CRYPTFF: cli_file = 535;
pub const cli_file_CL_TYPE_PDF: cli_file = 536;
pub const cli_file_CL_TYPE_UUENCODED: cli_file = 537;
pub const cli_file_CL_TYPE_SCRIPT: cli_file = 538;
pub const cli_file_CL_TYPE_HTML_UTF16: cli_file = 539;
pub const cli_file_CL_TYPE_RTF: cli_file = 540;
pub const cli_file_CL_TYPE_7Z: cli_file = 541;
pub const cli_file_CL_TYPE_SWF: cli_file = 542;
pub const cli_file_CL_TYPE_JAVA: cli_file = 543;
pub const cli_file_CL_TYPE_XAR: cli_file = 544;
pub const cli_file_CL_TYPE_XZ: cli_file = 545;
pub const cli_file_CL_TYPE_OOXML_WORD: cli_file = 546;
pub const cli_file_CL_TYPE_OOXML_PPT: cli_file = 547;
pub const cli_file_CL_TYPE_OOXML_XL: cli_file = 548;
pub const cli_file_CL_TYPE_INTERNAL: cli_file = 549;
pub const cli_file_CL_TYPE_HWP3: cli_file = 550;
pub const cli_file_CL_TYPE_OOXML_HWP: cli_file = 551;
pub const cli_file_CL_TYPE_PS: cli_file = 552;
pub const cli_file_CL_TYPE_EGG: cli_file = 553;
pub const cli_file_CL_TYPE_PART_ANY: cli_file = 554;
pub const cli_file_CL_TYPE_PART_HFSPLUS: cli_file = 555;
pub const cli_file_CL_TYPE_MBR: cli_file = 556;
pub const cli_file_CL_TYPE_HTML: cli_file = 557;
pub const cli_file_CL_TYPE_MAIL: cli_file = 558;
pub const cli_file_CL_TYPE_SFX: cli_file = 559;
pub const cli_file_CL_TYPE_ZIPSFX: cli_file = 560;
pub const cli_file_CL_TYPE_RARSFX: cli_file = 561;
pub const cli_file_CL_TYPE_7ZSFX: cli_file = 562;
pub const cli_file_CL_TYPE_CABSFX: cli_file = 563;
pub const cli_file_CL_TYPE_ARJSFX: cli_file = 564;
pub const cli_file_CL_TYPE_EGGSFX: cli_file = 565;
pub const cli_file_CL_TYPE_NULSFT: cli_file = 566;
pub const cli_file_CL_TYPE_AUTOIT: cli_file = 567;
pub const cli_file_CL_TYPE_ISHIELD_MSI: cli_file = 568;
pub const cli_file_CL_TYPE_ISO9660: cli_file = 569;
pub const cli_file_CL_TYPE_DMG: cli_file = 570;
pub const cli_file_CL_TYPE_GPT: cli_file = 571;
pub const cli_file_CL_TYPE_APM: cli_file = 572;
pub const cli_file_CL_TYPE_XDP: cli_file = 573;
pub const cli_file_CL_TYPE_XML_WORD: cli_file = 574;
pub const cli_file_CL_TYPE_XML_XL: cli_file = 575;
pub const cli_file_CL_TYPE_XML_HWP: cli_file = 576;
pub const cli_file_CL_TYPE_HWPOLE2: cli_file = 577;
pub const cli_file_CL_TYPE_MHTML: cli_file = 578;
pub const cli_file_CL_TYPE_LNK: cli_file = 579;
pub const cli_file_CL_TYPE_OTHER: cli_file = 580;
pub const cli_file_CL_TYPE_IGNORED: cli_file = 581;
pub type cli_file = ::std::os::raw::c_uint;
pub use self::cli_file as cli_file_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_ftype {
    pub type_: cli_file_t,
    pub offset: u32,
    pub magic: *mut ::std::os::raw::c_uchar,
    pub tname: *mut ::std::os::raw::c_char,
    pub next: *mut cli_ftype,
    pub length: u16,
}
pub type mpool_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_dconf {
    pub pe: u32,
    pub elf: u32,
    pub macho: u32,
    pub archive: u32,
    pub doc: u32,
    pub mail: u32,
    pub other: u32,
    pub phishing: u32,
    pub bytecode: u32,
    pub stats: u32,
    pub pcre: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct regex_t {
    pub re_magic: ::std::os::raw::c_int,
    pub re_nsub: size_t,
    pub re_endp: *const ::std::os::raw::c_char,
    pub re_g: *mut re_guts,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bytecode_metadata {
    pub compiler: *mut ::std::os::raw::c_char,
    pub sigmaker: *mut ::std::os::raw::c_char,
    pub timestamp: u64,
    pub formatlevel: ::std::os::raw::c_uint,
    pub minfunc: ::std::os::raw::c_uint,
    pub maxfunc: ::std::os::raw::c_uint,
    pub maxresource: ::std::os::raw::c_uint,
    pub targetExclude: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_environment {
    pub platform_id_a: u32,
    pub platform_id_b: u32,
    pub platform_id_c: u32,
    pub c_version: u32,
    pub cpp_version: u32,
    pub functionality_level: u32,
    pub dconf_level: u32,
    pub engine_version: [i8; 65usize],
    pub triple: [i8; 65usize],
    pub cpu: [i8; 65usize],
    pub sysname: [i8; 65usize],
    pub release: [i8; 65usize],
    pub version: [i8; 65usize],
    pub machine: [i8; 65usize],
    pub big_endian: u8,
    pub sizeof_ptr: u8,
    pub arch: u8,
    pub os_category: u8,
    pub os: u8,
    pub compiler: u8,
    pub has_jit_compiled: u8,
    pub os_features: u8,
    pub reserved0: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_bc_func {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_bc_type {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_bc_dbgnode {
    _unused: [u8; 0],
}
pub const bc_state_bc_skip: bc_state = 0;
pub const bc_state_bc_loaded: bc_state = 1;
pub const bc_state_bc_jit: bc_state = 2;
pub const bc_state_bc_interp: bc_state = 3;
pub const bc_state_bc_disabled: bc_state = 4;
pub type bc_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_bc {
    pub metadata: bytecode_metadata,
    pub id: ::std::os::raw::c_uint,
    pub kind: ::std::os::raw::c_uint,
    pub num_types: ::std::os::raw::c_uint,
    pub num_func: ::std::os::raw::c_uint,
    pub funcs: *mut cli_bc_func,
    pub types: *mut cli_bc_type,
    pub globals: *mut *mut u64,
    pub globaltys: *mut u16,
    pub num_globals: size_t,
    pub state: bc_state,
    pub uses_apis: *mut bitset_tag,
    pub lsig: *mut ::std::os::raw::c_char,
    pub vnameprefix: *mut ::std::os::raw::c_char,
    pub vnames: *mut *mut ::std::os::raw::c_char,
    pub vnames_cnt: ::std::os::raw::c_uint,
    pub start_tid: u16,
    pub dbgnodes: *mut cli_bc_dbgnode,
    pub dbgnode_cnt: ::std::os::raw::c_uint,
    pub hook_lsig_id: ::std::os::raw::c_uint,
    pub trusted: ::std::os::raw::c_uint,
    pub numGlobalBytes: u32,
    pub globalBytes: *mut u8,
    pub sigtime_id: u32,
    pub sigmatch_id: u32,
    pub hook_name: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_all_bc {
    pub all_bcs: *mut cli_bc,
    pub count: ::std::os::raw::c_uint,
    pub engine: *mut cli_bcengine,
    pub env: cli_environment,
    pub inited: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_events {
    _unused: [u8; 0],
}
pub type cli_events_t = cli_events;
pub type ulong64 = ::std::os::raw::c_ulong;
pub type fp_digit = ulong64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fp_int {
    pub dp: [fp_digit; 136usize],
    pub used: ::std::os::raw::c_int,
    pub sign: ::std::os::raw::c_int,
}
pub type mp_int = fp_int;
pub const cli_crt_hashtype_CLI_HASHTYPE_ANY: cli_crt_hashtype = 0;
pub const cli_crt_hashtype_CLI_SHA1RSA: cli_crt_hashtype = 1;
pub const cli_crt_hashtype_CLI_MD5RSA: cli_crt_hashtype = 2;
pub const cli_crt_hashtype_CLI_MD2RSA: cli_crt_hashtype = 3;
pub const cli_crt_hashtype_CLI_RSA: cli_crt_hashtype = 4;
pub const cli_crt_hashtype_CLI_SHA256RSA: cli_crt_hashtype = 5;
pub const cli_crt_hashtype_CLI_SHA384RSA: cli_crt_hashtype = 6;
pub const cli_crt_hashtype_CLI_SHA512RSA: cli_crt_hashtype = 7;
pub type cli_crt_hashtype = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_crt_t {
    pub name: *mut ::std::os::raw::c_char,
    pub raw_subject: [u8; 64usize],
    pub raw_issuer: [u8; 64usize],
    pub raw_serial: [u8; 64usize],
    pub subject: [u8; 20usize],
    pub issuer: [u8; 20usize],
    pub serial: [u8; 20usize],
    pub ignore_serial: ::std::os::raw::c_int,
    pub tbshash: [u8; 64usize],
    pub n: mp_int,
    pub e: mp_int,
    pub sig: mp_int,
    pub not_before: time_t,
    pub not_after: time_t,
    pub hashtype: cli_crt_hashtype,
    pub certSign: ::std::os::raw::c_int,
    pub codeSign: ::std::os::raw::c_int,
    pub timeSign: ::std::os::raw::c_int,
    pub isBlocked: ::std::os::raw::c_int,
    pub prev: *mut cli_crt_t,
    pub next: *mut cli_crt_t,
}
pub type cli_crt = cli_crt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crtmgr {
    pub crts: *mut cli_crt,
    pub items: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bitset_tag {
    pub bitset: *mut ::std::os::raw::c_uchar,
    pub length: ::std::os::raw::c_ulong,
}
pub type bitset_t = bitset_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct recursion_level_tag {
    pub type_: cli_file_t,
    pub size: size_t,
    pub fmap: *mut cl_fmap_t,
    pub recursion_level_buffer: u32,
    pub recursion_level_buffer_fmap: u32,
    pub is_normalized_layer: bool,
}
pub type recursion_level_t = recursion_level_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_ctx_tag {
    #[doc = "< (optional) The filepath of the original scan target."]
    pub target_filepath: *mut ::std::os::raw::c_char,
    #[doc = "< (optional) The filepath of the current file being parsed. May be a temp file."]
    pub sub_filepath: *const ::std::os::raw::c_char,
    #[doc = "< The directory to store tmp files at this recursion depth."]
    pub sub_tmpdir: *mut ::std::os::raw::c_char,
    pub virname: *mut *const ::std::os::raw::c_char,
    pub num_viruses: ::std::os::raw::c_uint,
    pub scanned: *mut ::std::os::raw::c_ulong,
    pub root: *const cli_matcher,
    pub engine: *const cl_engine,
    pub scansize: u64,
    pub options: *mut cl_scan_options,
    pub scannedfiles: ::std::os::raw::c_uint,
    pub found_possibly_unwanted: ::std::os::raw::c_uint,
    pub corrupted_input: ::std::os::raw::c_uint,
    pub img_validate: ::std::os::raw::c_uint,
    pub recursion_stack: *mut recursion_level_t,
    pub recursion_stack_size: u32,
    pub recursion_level: u32,
    pub fmap: *mut fmap_t,
    pub next_layer_is_normalized: bool,
    pub handlertype_hash: [::std::os::raw::c_uchar; 16usize],
    pub dconf: *mut cli_dconf,
    pub hook_lsig_matches: *mut bitset_t,
    pub cb_ctx: *mut ::std::os::raw::c_void,
    pub perf: *mut cli_events_t,
    pub time_limit: timeval,
    pub limit_exceeded: bool,
    pub abort_scan: bool,
}
pub type cli_ctx = cli_ctx_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icomtr {
    pub group: [::std::os::raw::c_uint; 2usize],
    pub color_avg: [::std::os::raw::c_uint; 3usize],
    pub color_x: [::std::os::raw::c_uint; 3usize],
    pub color_y: [::std::os::raw::c_uint; 3usize],
    pub gray_avg: [::std::os::raw::c_uint; 3usize],
    pub gray_x: [::std::os::raw::c_uint; 3usize],
    pub gray_y: [::std::os::raw::c_uint; 3usize],
    pub bright_avg: [::std::os::raw::c_uint; 3usize],
    pub bright_x: [::std::os::raw::c_uint; 3usize],
    pub bright_y: [::std::os::raw::c_uint; 3usize],
    pub dark_avg: [::std::os::raw::c_uint; 3usize],
    pub dark_x: [::std::os::raw::c_uint; 3usize],
    pub dark_y: [::std::os::raw::c_uint; 3usize],
    pub edge_avg: [::std::os::raw::c_uint; 3usize],
    pub edge_x: [::std::os::raw::c_uint; 3usize],
    pub edge_y: [::std::os::raw::c_uint; 3usize],
    pub noedge_avg: [::std::os::raw::c_uint; 3usize],
    pub noedge_x: [::std::os::raw::c_uint; 3usize],
    pub noedge_y: [::std::os::raw::c_uint; 3usize],
    pub rsum: ::std::os::raw::c_uint,
    pub gsum: ::std::os::raw::c_uint,
    pub bsum: ::std::os::raw::c_uint,
    pub ccount: ::std::os::raw::c_uint,
    pub name: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icon_matcher {
    pub group_names: [*mut *mut ::std::os::raw::c_char; 2usize],
    pub group_counts: [::std::os::raw::c_uint; 2usize],
    pub icons: [*mut icomtr; 3usize],
    pub icon_counts: [::std::os::raw::c_uint; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_dbinfo {
    pub name: *mut ::std::os::raw::c_char,
    pub hash: *mut ::std::os::raw::c_char,
    pub size: size_t,
    pub cvd: *mut cl_cvd,
    pub next: *mut cli_dbinfo,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_pwdb {
    pub name: *mut ::std::os::raw::c_char,
    pub passwd: *mut ::std::os::raw::c_char,
    pub length: u16,
    pub next: *mut cli_pwdb,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cl_engine {
    pub refcount: u32,
    pub sdb: u32,
    pub dboptions: u32,
    pub dbversion: [u32; 2usize],
    pub ac_only: u32,
    pub ac_mindepth: u32,
    pub ac_maxdepth: u32,
    pub tmpdir: *mut ::std::os::raw::c_char,
    pub keeptmp: u32,
    pub engine_options: u64,
    pub maxscantime: u32,
    pub maxscansize: u64,
    pub maxfilesize: u64,
    pub max_recursion_level: u32,
    pub maxfiles: u32,
    pub min_cc_count: u32,
    pub min_ssn_count: u32,
    pub root: *mut *mut cli_matcher,
    pub hm_hdb: *mut cli_matcher,
    pub hm_mdb: *mut cli_matcher,
    pub hm_imp: *mut cli_matcher,
    pub hm_fp: *mut cli_matcher,
    pub cdb: *mut cli_cdb,
    pub allow_list_matcher: *mut regex_matcher,
    pub domain_list_matcher: *mut regex_matcher,
    pub phishcheck: *mut phishcheck,
    pub dconf: *mut cli_dconf,
    pub ftypes: *mut cli_ftype,
    pub ptypes: *mut cli_ftype,
    pub pwdbs: *mut *mut cli_pwdb,
    pub test_root: *mut cli_matcher,
    pub ignored: *mut cli_matcher,
    pub pua_cats: *mut ::std::os::raw::c_char,
    pub iconcheck: *mut icon_matcher,
    pub cache: *mut CACHE,
    pub dbinfo: *mut cli_dbinfo,
    pub num_total_signatures: size_t,
    pub mempool: *mut mpool_t,
    pub cmgr: crtmgr,
    pub cb_pre_cache: clcb_pre_cache,
    pub cb_pre_scan: clcb_pre_scan,
    pub cb_post_scan: clcb_post_scan,
    pub cb_virus_found: clcb_virus_found,
    pub cb_sigload: clcb_sigload,
    pub cb_sigload_ctx: *mut ::std::os::raw::c_void,
    pub cb_hash: clcb_hash,
    pub cb_meta: clcb_meta,
    pub cb_file_props: clcb_file_props,
    pub cb_sigload_progress: clcb_progress,
    pub cb_sigload_progress_ctx: *mut ::std::os::raw::c_void,
    pub cb_engine_compile_progress: clcb_progress,
    pub cb_engine_compile_progress_ctx: *mut ::std::os::raw::c_void,
    pub cb_engine_free_progress: clcb_progress,
    pub cb_engine_free_progress_ctx: *mut ::std::os::raw::c_void,
    pub bcs: cli_all_bc,
    pub hooks: [*mut ::std::os::raw::c_uint; 7usize],
    pub hooks_cnt: [::std::os::raw::c_uint; 7usize],
    pub hook_lsig_ids: ::std::os::raw::c_uint,
    pub bytecode_security: bytecode_security,
    pub bytecode_timeout: u32,
    pub bytecode_mode: bytecode_mode,
    pub maxembeddedpe: u64,
    pub maxhtmlnormalize: u64,
    pub maxhtmlnotags: u64,
    pub maxscriptnormalize: u64,
    pub maxziptypercg: u64,
    pub stats_data: *mut ::std::os::raw::c_void,
    pub cb_stats_add_sample: clcb_stats_add_sample,
    pub cb_stats_remove_sample: clcb_stats_remove_sample,
    pub cb_stats_decrement_count: clcb_stats_decrement_count,
    pub cb_stats_submit: clcb_stats_submit,
    pub cb_stats_flush: clcb_stats_flush,
    pub cb_stats_get_num: clcb_stats_get_num,
    pub cb_stats_get_size: clcb_stats_get_size,
    pub cb_stats_get_hostid: clcb_stats_get_hostid,
    pub maxpartitions: u32,
    pub maxiconspe: u32,
    pub maxrechwp3: u32,
    pub pcre_match_limit: u64,
    pub pcre_recmatch_limit: u64,
    pub pcre_max_filesize: u64,
}
extern "C" {
    #[doc = " @brief Append an alert."]
    #[doc = ""]
    #[doc = " An FP-check will verify that the file is not allowed."]
    #[doc = " The allow list check does not happen before the scan because allowing files"]
    #[doc = " is so infrequent that such action would be detrimental to performance."]
    #[doc = ""]
    #[doc = " TODO: Replace implementation with severity scale, and severity threshold"]
    #[doc = " wherein signatures that do not meet the threshold are documented in JSON"]
    #[doc = " metadata but do not halt the scan."]
    #[doc = ""]
    #[doc = " @param ctx       The scan context."]
    #[doc = " @param virname   The alert name."]
    #[doc = " @return cl_error_t CL_VIRUS if scan should be halted due to an alert, CL_CLEAN if scan should continue."]
    pub fn cli_append_virus(
        ctx: *mut cli_ctx,
        virname: *const ::std::os::raw::c_char,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_warnmsg(str_: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn cli_errmsg(str_: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn cli_infomsg_simple(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn cli_dbgmsg_no_inline(str_: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " @brief   Get the libclamav debug flag (e.g. if debug logging is enabled)"]
    #[doc = ""]
    #[doc = " This is required for unit tests to be able to link with clamav.dll and not"]
    #[doc = " directly manipulate libclamav global variables."]
    pub fn cli_get_debug_flag() -> u8;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cli_htu32_element {
    pub key: u32,
    pub data: cli_htu32_element__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cli_htu32_element__bindgen_ty_1 {
    pub as_size_t: size_t,
    pub as_ptr: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_htu32 {
    pub htable: *mut cli_htu32_element,
    pub capacity: size_t,
    pub used: size_t,
    pub maxfill: size_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_hashset {
    pub keys: *mut u32,
    pub bitmap: *mut u32,
    pub mempool: *mut mpool_t,
    pub capacity: u32,
    pub mask: u32,
    pub count: u32,
    pub limit: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_subsig_matches {
    pub last: u32,
    pub next: u32,
    pub offsets: [u32; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_lsig_matches {
    pub subsigs: u32,
    pub matches: [*mut cli_subsig_matches; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_ac_data {
    pub offmatrix: *mut *mut *mut u32,
    pub partsigs: u32,
    pub lsigs: u32,
    pub reloffsigs: u32,
    pub lsigcnt: *mut *mut u32,
    pub lsigsuboff_last: *mut *mut u32,
    pub lsigsuboff_first: *mut *mut u32,
    pub lsig_matches: *mut *mut cli_lsig_matches,
    pub yr_matches: *mut u8,
    pub offset: *mut u32,
    pub macro_lastmatch: [u32; 32usize],
    #[doc = " Hashset for versioninfo matching"]
    pub vinfo: *const cli_hashset,
    pub min_partno: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_alt_node {
    pub str_: *mut u16,
    pub len: u16,
    pub unique: u8,
    pub next: *mut cli_alt_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cli_ac_special {
    pub alt: cli_ac_special__bindgen_ty_1,
    pub len: [u16; 2usize],
    pub num: u16,
    pub type_: u16,
    pub negative: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cli_ac_special__bindgen_ty_1 {
    pub byte: *mut ::std::os::raw::c_uchar,
    pub f_str: *mut *mut ::std::os::raw::c_uchar,
    pub v_str: *mut cli_alt_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_ac_patt {
    pub pattern: *mut u16,
    pub prefix: *mut u16,
    pub length: [u16; 3usize],
    pub prefix_length: [u16; 3usize],
    pub mindist: u32,
    pub maxdist: u32,
    pub sigid: u32,
    pub lsigid: [u32; 3usize],
    pub ch: [u16; 2usize],
    pub virname: *mut ::std::os::raw::c_char,
    pub customdata: *mut ::std::os::raw::c_void,
    pub ch_mindist: [u16; 2usize],
    pub ch_maxdist: [u16; 2usize],
    pub parts: u16,
    pub partno: u16,
    pub special: u16,
    pub special_pattern: u16,
    pub special_table: *mut *mut cli_ac_special,
    pub rtype: u16,
    pub type_: u16,
    pub offdata: [u32; 4usize],
    pub offset_min: u32,
    pub offset_max: u32,
    pub boundary: u32,
    pub depth: u8,
    pub sigopts: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cli_ac_list {
    pub me: *mut cli_ac_patt,
    pub __bindgen_anon_1: cli_ac_list__bindgen_ty_1,
    pub next_same: *mut cli_ac_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cli_ac_list__bindgen_ty_1 {
    pub node: *mut cli_ac_node,
    pub next: *mut cli_ac_list,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_ac_node {
    pub list: *mut cli_ac_list,
    pub trans: *mut *mut cli_ac_node,
    pub fail: *mut cli_ac_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_ac_result {
    pub virname: *const ::std::os::raw::c_char,
    pub customdata: *mut ::std::os::raw::c_void,
    pub offset: off_t,
    pub next: *mut cli_ac_result,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_bm_patt {
    pub pattern: *mut ::std::os::raw::c_uchar,
    pub prefix: *mut ::std::os::raw::c_uchar,
    pub virname: *mut ::std::os::raw::c_char,
    pub offdata: [u32; 4usize],
    pub offset_min: u32,
    pub offset_max: u32,
    pub next: *mut cli_bm_patt,
    pub length: u16,
    pub prefix_length: u16,
    pub cnt: u16,
    pub pattern0: ::std::os::raw::c_uchar,
    pub boundary: u32,
    pub filesize: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_sz_hash {
    pub hash_array: *mut u8,
    pub virusnames: *mut *const ::std::os::raw::c_char,
    pub items: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_hash_patt {
    pub sizehashes: [cli_htu32; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_hash_wild {
    pub hashes: [cli_sz_hash; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_real_match_context_8 {
    _unused: [u8; 0],
}
pub type pcre2_match_context_8 = pcre2_real_match_context_8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_real_code_8 {
    _unused: [u8; 0],
}
pub type pcre2_code_8 = pcre2_real_code_8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_pcre_data {
    pub re: *mut pcre2_code_8,
    pub mctx: *mut pcre2_match_context_8,
    pub options: ::std::os::raw::c_int,
    pub expression: *mut ::std::os::raw::c_char,
    pub search_offset: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_pcre_meta {
    pub trigger: *mut ::std::os::raw::c_char,
    pub virname: *mut ::std::os::raw::c_char,
    pub lsigid: [u32; 3usize],
    pub pdata: cli_pcre_data,
    pub offdata: [u32; 4usize],
    pub offset_min: u32,
    pub offset_max: u32,
    pub flags: u32,
    pub statname: *mut ::std::os::raw::c_char,
    pub sigtime_id: u32,
    pub sigmatch_id: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_bcomp_meta {
    pub virname: *mut ::std::os::raw::c_char,
    pub ref_subsigid: u16,
    pub lsigid: [u32; 3usize],
    pub offset: ssize_t,
    pub options: u16,
    pub byte_len: size_t,
    pub comps: *mut *mut cli_bcomp_comp,
    pub comp_count: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_bcomp_comp {
    pub comp_symbol: ::std::os::raw::c_char,
    pub comp_value: i64,
}
pub const tdb_type_CLI_TDB_UINT: tdb_type = 0;
pub const tdb_type_CLI_TDB_RANGE: tdb_type = 1;
pub const tdb_type_CLI_TDB_STR: tdb_type = 2;
pub const tdb_type_CLI_TDB_RANGE2: tdb_type = 3;
pub const tdb_type_CLI_TDB_FTYPE: tdb_type = 4;
pub const tdb_type_CLI_TDB_FTYPE_EXPR: tdb_type = 5;
pub type tdb_type = ::std::os::raw::c_uint;
pub use self::tdb_type as tdb_type_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_lsig_tdb {
    pub val: *mut u32,
    pub range: *mut u32,
    pub str_: *mut ::std::os::raw::c_char,
    pub cnt: [tdb_type_t; 3usize],
    pub subsigs: u32,
    pub target: *const u32,
    pub engine: *const u32,
    pub nos: *const u32,
    pub ep: *const u32,
    pub filesize: *const u32,
    pub container: *const u32,
    pub handlertype: *const u32,
    pub intermediates: *const u32,
    pub icongrp1: *const ::std::os::raw::c_char,
    pub icongrp2: *const ::std::os::raw::c_char,
    pub macro_ptids: *mut u32,
    pub mempool: *mut mpool_t,
}
pub const lsig_type_CLI_LSIG_NORMAL: lsig_type = 0;
pub const lsig_type_CLI_YARA_NORMAL: lsig_type = 1;
pub const lsig_type_CLI_YARA_OFFSET: lsig_type = 2;
pub type lsig_type = ::std::os::raw::c_uint;
pub use self::lsig_type as lsig_type_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cli_ac_lsig {
    pub id: u32,
    pub bc_idx: ::std::os::raw::c_uint,
    pub type_: lsig_type_t,
    pub flag: u8,
    pub u: cli_ac_lsig__bindgen_ty_1,
    pub virname: *const ::std::os::raw::c_char,
    pub tdb: cli_lsig_tdb,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cli_ac_lsig__bindgen_ty_1 {
    pub logic: *mut ::std::os::raw::c_char,
    pub code_start: *mut u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_matcher {
    pub type_: ::std::os::raw::c_uint,
    pub bm_shift: *mut u8,
    pub bm_suffix: *mut *mut cli_bm_patt,
    pub bm_pattab: *mut *mut cli_bm_patt,
    pub soff: *mut u32,
    pub soff_len: u32,
    pub bm_offmode: u32,
    pub bm_patterns: u32,
    pub bm_reloff_num: u32,
    pub bm_absoff_num: u32,
    pub hm: cli_hash_patt,
    pub hwild: cli_hash_wild,
    pub ac_partsigs: u32,
    pub ac_nodes: u32,
    pub ac_lists: u32,
    pub ac_patterns: u32,
    pub ac_lsigs: u32,
    pub ac_lsigtable: *mut *mut cli_ac_lsig,
    pub ac_root: *mut cli_ac_node,
    pub ac_nodetable: *mut *mut cli_ac_node,
    pub ac_listtable: *mut *mut cli_ac_list,
    pub ac_pattable: *mut *mut cli_ac_patt,
    pub ac_reloff: *mut *mut cli_ac_patt,
    pub ac_reloff_num: u32,
    pub ac_absoff_num: u32,
    pub ac_mindepth: u8,
    pub ac_maxdepth: u8,
    pub filter: *mut filter,
    pub maxpatlen: u16,
    pub ac_only: u8,
    pub pcre_metas: u32,
    pub pcre_metatable: *mut *mut cli_pcre_meta,
    pub pcre_reloff_num: u32,
    pub pcre_absoff_num: u32,
    pub bcomp_metas: u32,
    pub bcomp_metatable: *mut *mut cli_bcomp_meta,
    pub linked_bcs: u32,
    pub mempool: *mut mpool_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_cdb {
    pub virname: *mut ::std::os::raw::c_char,
    pub ctype: cli_file_t,
    pub name: regex_t,
    pub csize: [size_t; 2usize],
    pub fsizec: [size_t; 2usize],
    pub fsizer: [size_t; 2usize],
    pub encrypted: ::std::os::raw::c_int,
    pub filepos: [::std::os::raw::c_uint; 2usize],
    pub res1: ::std::os::raw::c_int,
    pub res2: *mut ::std::os::raw::c_void,
    pub next: *mut cli_cdb,
}
extern "C" {
    pub fn cli_versig2(
        sha256: *const ::std::os::raw::c_uchar,
        dsig_str: *const ::std::os::raw::c_char,
        n_str: *const ::std::os::raw::c_char,
        e_str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_getdsig(
        host: *const ::std::os::raw::c_char,
        user: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_uchar,
        datalen: ::std::os::raw::c_uint,
        mode: ::std::os::raw::c_ushort,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct re_guts {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_bcengine {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct regex_matcher {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phishcheck {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CACHE {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filter {
    pub _address: u8,
}

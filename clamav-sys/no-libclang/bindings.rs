/* automatically generated by rust-bindgen 0.69.2 */

pub const CL_DB_PHISHING: u32 = 2;
pub const CL_DB_PHISHING_URLS: u32 = 8;
pub const CL_DB_PUA: u32 = 16;
pub const CL_DB_CVDNOTMP: u32 = 32;
pub const CL_DB_OFFICIAL: u32 = 64;
pub const CL_DB_PUA_MODE: u32 = 128;
pub const CL_DB_PUA_INCLUDE: u32 = 256;
pub const CL_DB_PUA_EXCLUDE: u32 = 512;
pub const CL_DB_COMPILED: u32 = 1024;
pub const CL_DB_DIRECTORY: u32 = 2048;
pub const CL_DB_OFFICIAL_ONLY: u32 = 4096;
pub const CL_DB_BYTECODE: u32 = 8192;
pub const CL_DB_SIGNED: u32 = 16384;
pub const CL_DB_BYTECODE_UNSIGNED: u32 = 32768;
pub const CL_DB_UNSIGNED: u32 = 65536;
pub const CL_DB_BYTECODE_STATS: u32 = 131072;
pub const CL_DB_ENHANCED: u32 = 262144;
pub const CL_DB_PCRE_STATS: u32 = 524288;
pub const CL_DB_YARA_EXCLUDE: u32 = 1048576;
pub const CL_DB_YARA_ONLY: u32 = 2097152;
pub const CL_DB_STDOPT: u32 = 8202;
pub const CL_SCAN_GENERAL_ALLMATCHES: u32 = 1;
pub const CL_SCAN_GENERAL_COLLECT_METADATA: u32 = 2;
pub const CL_SCAN_GENERAL_HEURISTICS: u32 = 4;
pub const CL_SCAN_GENERAL_HEURISTIC_PRECEDENCE: u32 = 8;
pub const CL_SCAN_GENERAL_UNPRIVILEGED: u32 = 16;
pub const CL_SCAN_PARSE_ARCHIVE: u32 = 1;
pub const CL_SCAN_PARSE_ELF: u32 = 2;
pub const CL_SCAN_PARSE_PDF: u32 = 4;
pub const CL_SCAN_PARSE_SWF: u32 = 8;
pub const CL_SCAN_PARSE_HWP3: u32 = 16;
pub const CL_SCAN_PARSE_XMLDOCS: u32 = 32;
pub const CL_SCAN_PARSE_MAIL: u32 = 64;
pub const CL_SCAN_PARSE_OLE2: u32 = 128;
pub const CL_SCAN_PARSE_HTML: u32 = 256;
pub const CL_SCAN_PARSE_PE: u32 = 512;
pub const CL_SCAN_PARSE_ONENOTE: u32 = 1024;
pub const CL_SCAN_HEURISTIC_BROKEN: u32 = 2;
pub const CL_SCAN_HEURISTIC_EXCEEDS_MAX: u32 = 4;
pub const CL_SCAN_HEURISTIC_PHISHING_SSL_MISMATCH: u32 = 8;
pub const CL_SCAN_HEURISTIC_PHISHING_CLOAK: u32 = 16;
pub const CL_SCAN_HEURISTIC_MACROS: u32 = 32;
pub const CL_SCAN_HEURISTIC_ENCRYPTED_ARCHIVE: u32 = 64;
pub const CL_SCAN_HEURISTIC_ENCRYPTED_DOC: u32 = 128;
pub const CL_SCAN_HEURISTIC_PARTITION_INTXN: u32 = 256;
pub const CL_SCAN_HEURISTIC_STRUCTURED: u32 = 512;
pub const CL_SCAN_HEURISTIC_STRUCTURED_SSN_NORMAL: u32 = 1024;
pub const CL_SCAN_HEURISTIC_STRUCTURED_SSN_STRIPPED: u32 = 2048;
pub const CL_SCAN_HEURISTIC_STRUCTURED_CC: u32 = 4096;
pub const CL_SCAN_HEURISTIC_BROKEN_MEDIA: u32 = 8192;
pub const CL_SCAN_MAIL_PARTIAL_MESSAGE: u32 = 1;
pub const CL_SCAN_DEV_COLLECT_SHA: u32 = 1;
pub const CL_SCAN_DEV_COLLECT_PERFORMANCE_INFO: u32 = 2;
pub const ENGINE_OPTIONS_NONE: u32 = 0;
pub const ENGINE_OPTIONS_DISABLE_CACHE: u32 = 1;
pub const ENGINE_OPTIONS_FORCE_TO_DISK: u32 = 2;
pub const ENGINE_OPTIONS_DISABLE_PE_STATS: u32 = 4;
pub const ENGINE_OPTIONS_DISABLE_PE_CERTS: u32 = 8;
pub const ENGINE_OPTIONS_PE_DUMPCERTS: u32 = 16;
pub const CL_INIT_DEFAULT: u32 = 0;
pub const LAYER_ATTRIBUTES_NONE: u32 = 0;
pub const LAYER_ATTRIBUTES_NORMALIZED: u32 = 1;
pub const LAYER_ATTRIBUTES_DECRYPTED: u32 = 2;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_off_t = __int64_t;
pub type time_t = __darwin_time_t;
pub type off_t = __darwin_off_t;
impl cl_error_t {
    pub const CL_CLEAN: cl_error_t = cl_error_t(0);
}
impl cl_error_t {
    pub const CL_SUCCESS: cl_error_t = cl_error_t(0);
}
impl cl_error_t {
    pub const CL_VIRUS: cl_error_t = cl_error_t(1);
}
impl cl_error_t {
    pub const CL_ENULLARG: cl_error_t = cl_error_t(2);
}
impl cl_error_t {
    pub const CL_EARG: cl_error_t = cl_error_t(3);
}
impl cl_error_t {
    pub const CL_EMALFDB: cl_error_t = cl_error_t(4);
}
impl cl_error_t {
    pub const CL_ECVD: cl_error_t = cl_error_t(5);
}
impl cl_error_t {
    pub const CL_EVERIFY: cl_error_t = cl_error_t(6);
}
impl cl_error_t {
    pub const CL_EUNPACK: cl_error_t = cl_error_t(7);
}
impl cl_error_t {
    pub const CL_EOPEN: cl_error_t = cl_error_t(8);
}
impl cl_error_t {
    pub const CL_ECREAT: cl_error_t = cl_error_t(9);
}
impl cl_error_t {
    pub const CL_EUNLINK: cl_error_t = cl_error_t(10);
}
impl cl_error_t {
    pub const CL_ESTAT: cl_error_t = cl_error_t(11);
}
impl cl_error_t {
    pub const CL_EREAD: cl_error_t = cl_error_t(12);
}
impl cl_error_t {
    pub const CL_ESEEK: cl_error_t = cl_error_t(13);
}
impl cl_error_t {
    pub const CL_EWRITE: cl_error_t = cl_error_t(14);
}
impl cl_error_t {
    pub const CL_EDUP: cl_error_t = cl_error_t(15);
}
impl cl_error_t {
    pub const CL_EACCES: cl_error_t = cl_error_t(16);
}
impl cl_error_t {
    pub const CL_ETMPFILE: cl_error_t = cl_error_t(17);
}
impl cl_error_t {
    pub const CL_ETMPDIR: cl_error_t = cl_error_t(18);
}
impl cl_error_t {
    pub const CL_EMAP: cl_error_t = cl_error_t(19);
}
impl cl_error_t {
    pub const CL_EMEM: cl_error_t = cl_error_t(20);
}
impl cl_error_t {
    pub const CL_ETIMEOUT: cl_error_t = cl_error_t(21);
}
impl cl_error_t {
    pub const CL_BREAK: cl_error_t = cl_error_t(22);
}
impl cl_error_t {
    pub const CL_EMAXREC: cl_error_t = cl_error_t(23);
}
impl cl_error_t {
    pub const CL_EMAXSIZE: cl_error_t = cl_error_t(24);
}
impl cl_error_t {
    pub const CL_EMAXFILES: cl_error_t = cl_error_t(25);
}
impl cl_error_t {
    pub const CL_EFORMAT: cl_error_t = cl_error_t(26);
}
impl cl_error_t {
    pub const CL_EPARSE: cl_error_t = cl_error_t(27);
}
impl cl_error_t {
    pub const CL_EBYTECODE: cl_error_t = cl_error_t(28);
}
impl cl_error_t {
    pub const CL_EBYTECODE_TESTFAIL: cl_error_t = cl_error_t(29);
}
impl cl_error_t {
    pub const CL_ELOCK: cl_error_t = cl_error_t(30);
}
impl cl_error_t {
    pub const CL_EBUSY: cl_error_t = cl_error_t(31);
}
impl cl_error_t {
    pub const CL_ESTATE: cl_error_t = cl_error_t(32);
}
impl cl_error_t {
    pub const CL_VERIFIED: cl_error_t = cl_error_t(33);
}
impl cl_error_t {
    pub const CL_ERROR: cl_error_t = cl_error_t(34);
}
impl cl_error_t {
    pub const CL_ELAST_ERROR: cl_error_t = cl_error_t(35);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct cl_error_t(pub ::std::os::raw::c_uint);
#[doc = " scan options"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cl_scan_options {
    pub general: u32,
    pub parse: u32,
    pub heuristic: u32,
    pub mail: u32,
    pub dev: u32,
}
#[test]
fn bindgen_test_layout_cl_scan_options() {
    const UNINIT: ::std::mem::MaybeUninit<cl_scan_options> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cl_scan_options>(),
        20usize,
        concat!("Size of: ", stringify!(cl_scan_options))
    );
    assert_eq!(
        ::std::mem::align_of::<cl_scan_options>(),
        4usize,
        concat!("Alignment of ", stringify!(cl_scan_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).general) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_scan_options),
            "::",
            stringify!(general)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parse) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_scan_options),
            "::",
            stringify!(parse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heuristic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_scan_options),
            "::",
            stringify!(heuristic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mail) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_scan_options),
            "::",
            stringify!(mail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_scan_options),
            "::",
            stringify!(dev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cl_engine {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cl_settings {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Enable debug messages"]
    pub fn cl_debug();
}
extern "C" {
    #[doc = " @brief This function initializes the openssl crypto system.\n\n Called by cl_init() and does not need to be cleaned up as de-init\n is handled automatically by openssl 1.0.2.h and 1.1.0\n\n @return Always returns 0"]
    pub fn cl_initialize_crypto() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief This is a deprecated function that used to clean up ssl crypto inits.\n\n Call to EVP_cleanup() has been removed since cleanup is now handled by\n auto-deinit as of openssl 1.0.2h and 1.1.0"]
    pub fn cl_cleanup_crypto();
}
extern "C" {
    #[doc = " @brief Initialize the ClamAV library.\n\n @param initoptions   Unused.\n @return cl_error_t   CL_SUCCESS if everything initialized correctly."]
    pub fn cl_init(initoptions: ::std::os::raw::c_uint) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Allocate a new scanning engine and initialize default settings.\n\n The engine should be freed with `cl_engine_free()`.\n\n @return struct cl_engine* Pointer to the scanning engine."]
    pub fn cl_engine_new() -> *mut cl_engine;
}
impl cl_engine_field {
    pub const CL_ENGINE_MAX_SCANSIZE: cl_engine_field = cl_engine_field(0);
}
impl cl_engine_field {
    pub const CL_ENGINE_MAX_FILESIZE: cl_engine_field = cl_engine_field(1);
}
impl cl_engine_field {
    pub const CL_ENGINE_MAX_RECURSION: cl_engine_field = cl_engine_field(2);
}
impl cl_engine_field {
    pub const CL_ENGINE_MAX_FILES: cl_engine_field = cl_engine_field(3);
}
impl cl_engine_field {
    pub const CL_ENGINE_MIN_CC_COUNT: cl_engine_field = cl_engine_field(4);
}
impl cl_engine_field {
    pub const CL_ENGINE_MIN_SSN_COUNT: cl_engine_field = cl_engine_field(5);
}
impl cl_engine_field {
    pub const CL_ENGINE_PUA_CATEGORIES: cl_engine_field = cl_engine_field(6);
}
impl cl_engine_field {
    pub const CL_ENGINE_DB_OPTIONS: cl_engine_field = cl_engine_field(7);
}
impl cl_engine_field {
    pub const CL_ENGINE_DB_VERSION: cl_engine_field = cl_engine_field(8);
}
impl cl_engine_field {
    pub const CL_ENGINE_DB_TIME: cl_engine_field = cl_engine_field(9);
}
impl cl_engine_field {
    pub const CL_ENGINE_AC_ONLY: cl_engine_field = cl_engine_field(10);
}
impl cl_engine_field {
    pub const CL_ENGINE_AC_MINDEPTH: cl_engine_field = cl_engine_field(11);
}
impl cl_engine_field {
    pub const CL_ENGINE_AC_MAXDEPTH: cl_engine_field = cl_engine_field(12);
}
impl cl_engine_field {
    pub const CL_ENGINE_TMPDIR: cl_engine_field = cl_engine_field(13);
}
impl cl_engine_field {
    pub const CL_ENGINE_KEEPTMP: cl_engine_field = cl_engine_field(14);
}
impl cl_engine_field {
    pub const CL_ENGINE_BYTECODE_SECURITY: cl_engine_field = cl_engine_field(15);
}
impl cl_engine_field {
    pub const CL_ENGINE_BYTECODE_TIMEOUT: cl_engine_field = cl_engine_field(16);
}
impl cl_engine_field {
    pub const CL_ENGINE_BYTECODE_MODE: cl_engine_field = cl_engine_field(17);
}
impl cl_engine_field {
    pub const CL_ENGINE_MAX_EMBEDDEDPE: cl_engine_field = cl_engine_field(18);
}
impl cl_engine_field {
    pub const CL_ENGINE_MAX_HTMLNORMALIZE: cl_engine_field = cl_engine_field(19);
}
impl cl_engine_field {
    pub const CL_ENGINE_MAX_HTMLNOTAGS: cl_engine_field = cl_engine_field(20);
}
impl cl_engine_field {
    pub const CL_ENGINE_MAX_SCRIPTNORMALIZE: cl_engine_field = cl_engine_field(21);
}
impl cl_engine_field {
    pub const CL_ENGINE_MAX_ZIPTYPERCG: cl_engine_field = cl_engine_field(22);
}
impl cl_engine_field {
    pub const CL_ENGINE_FORCETODISK: cl_engine_field = cl_engine_field(23);
}
impl cl_engine_field {
    pub const CL_ENGINE_CACHE_SIZE: cl_engine_field = cl_engine_field(24);
}
impl cl_engine_field {
    pub const CL_ENGINE_DISABLE_CACHE: cl_engine_field = cl_engine_field(25);
}
impl cl_engine_field {
    pub const CL_ENGINE_DISABLE_PE_STATS: cl_engine_field = cl_engine_field(26);
}
impl cl_engine_field {
    pub const CL_ENGINE_STATS_TIMEOUT: cl_engine_field = cl_engine_field(27);
}
impl cl_engine_field {
    pub const CL_ENGINE_MAX_PARTITIONS: cl_engine_field = cl_engine_field(28);
}
impl cl_engine_field {
    pub const CL_ENGINE_MAX_ICONSPE: cl_engine_field = cl_engine_field(29);
}
impl cl_engine_field {
    pub const CL_ENGINE_MAX_RECHWP3: cl_engine_field = cl_engine_field(30);
}
impl cl_engine_field {
    pub const CL_ENGINE_MAX_SCANTIME: cl_engine_field = cl_engine_field(31);
}
impl cl_engine_field {
    pub const CL_ENGINE_PCRE_MATCH_LIMIT: cl_engine_field = cl_engine_field(32);
}
impl cl_engine_field {
    pub const CL_ENGINE_PCRE_RECMATCH_LIMIT: cl_engine_field = cl_engine_field(33);
}
impl cl_engine_field {
    pub const CL_ENGINE_PCRE_MAX_FILESIZE: cl_engine_field = cl_engine_field(34);
}
impl cl_engine_field {
    pub const CL_ENGINE_DISABLE_PE_CERTS: cl_engine_field = cl_engine_field(35);
}
impl cl_engine_field {
    pub const CL_ENGINE_PE_DUMPCERTS: cl_engine_field = cl_engine_field(36);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct cl_engine_field(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_section_hash {
    pub md5: [::std::os::raw::c_uchar; 16usize],
    pub len: usize,
}
#[test]
fn bindgen_test_layout_cli_section_hash() {
    const UNINIT: ::std::mem::MaybeUninit<cli_section_hash> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cli_section_hash>(),
        24usize,
        concat!("Size of: ", stringify!(cli_section_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_section_hash>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_section_hash))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).md5) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_section_hash),
            "::",
            stringify!(md5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_section_hash),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_stats_sections {
    pub nsections: usize,
    pub sections: *mut cli_section_hash,
}
#[test]
fn bindgen_test_layout_cli_stats_sections() {
    const UNINIT: ::std::mem::MaybeUninit<cli_stats_sections> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cli_stats_sections>(),
        16usize,
        concat!("Size of: ", stringify!(cli_stats_sections))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_stats_sections>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_stats_sections))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nsections) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_stats_sections),
            "::",
            stringify!(nsections)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sections) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_stats_sections),
            "::",
            stringify!(sections)
        )
    );
}
pub type stats_section_t = cli_stats_sections;
extern "C" {
    #[doc = " @brief Set a numerical engine option.\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine            An initialized scan engine.\n @param cl_engine_field   A CL_ENGINE option.\n @param num               The new engine option value.\n @return cl_error_t       CL_SUCCESS if successfully set.\n @return cl_error_t       CL_EARG if the field number was incorrect.\n @return cl_error_t       CL_ENULLARG null arguments were provided."]
    pub fn cl_engine_set_num(
        engine: *mut cl_engine,
        field: cl_engine_field,
        num: ::std::os::raw::c_longlong,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Get a numerical engine option.\n\n @param engine            An initialized scan engine.\n @param cl_engine_field   A CL_ENGINE option.\n @param err               (optional) A cl_error_t status code.\n @return long long        The numerical option value."]
    pub fn cl_engine_get_num(
        engine: *const cl_engine,
        field: cl_engine_field,
        err: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " @brief Set a string engine option.\n\n If the string option has already been set, the existing string will be free'd\n and the new string will replace it.\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine            An initialized scan engine.\n @param cl_engine_field   A CL_ENGINE option.\n @param str               The new engine option value.\n @return cl_error_t       CL_SUCCESS if successfully set.\n @return cl_error_t       CL_EARG if the field number was incorrect.\n @return cl_error_t       CL_EMEM if a memory allocation error occurred.\n @return cl_error_t       CL_ENULLARG null arguments were provided."]
    pub fn cl_engine_set_str(
        engine: *mut cl_engine,
        field: cl_engine_field,
        str_: *const ::std::os::raw::c_char,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Get a string engine option.\n\n @param engine            An initialized scan engine.\n @param cl_engine_field   A CL_ENGINE option.\n @param err               (optional) A cl_error_t status code.\n @return const char *     The string option value."]
    pub fn cl_engine_get_str(
        engine: *const cl_engine,
        field: cl_engine_field,
        err: *mut ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Copy the settings from an existing scan engine.\n\n The cl_settings pointer is allocated and must be freed with cl_engine_settings_free().\n\n @param engine                An configured scan engine.\n @return struct cl_settings*  The settings."]
    pub fn cl_engine_settings_copy(engine: *const cl_engine) -> *mut cl_settings;
}
extern "C" {
    #[doc = " @brief Apply settings from a settings structure to a scan engine.\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine        A scan engine.\n @param settings      The settings.\n @return cl_error_t   CL_SUCCESS if successful.\n @return cl_error_t   CL_EMEM if a memory allocation error occurred."]
    pub fn cl_engine_settings_apply(
        engine: *mut cl_engine,
        settings: *const cl_settings,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Free a settings struct pointer.\n\n @param settings      The settings struct pointer.\n @return cl_error_t   CL_SUCCESS if successful.\n @return cl_error_t   CL_ENULLARG null arguments were provided."]
    pub fn cl_engine_settings_free(settings: *mut cl_settings) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Prepare the scanning engine.\n\n Call this after all required databases have been loaded and settings have\n been applied.\n\n @param engine        A scan engine.\n @return cl_error_t   CL_SUCCESS if successful.\n @return cl_error_t   CL_ENULLARG null arguments were provided."]
    pub fn cl_engine_compile(engine: *mut cl_engine) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Add a reference count to the engine.\n\n Thread safety mechanism so that the engine is not free'd by another thread.\n\n The engine is initialized with refcount = 1, so this only needs to be called\n for additional scanning threads.\n\n @param engine        A scan engine.\n @return cl_error_t   CL_SUCCESS if successful.\n @return cl_error_t   CL_ENULLARG null arguments were provided."]
    pub fn cl_engine_addref(engine: *mut cl_engine) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Free an engine.\n\n Will lower the reference count on an engine. If the reference count hits\n zero, the engine will be freed.\n\n @param engine        A scan engine.\n @return cl_error_t   CL_SUCCESS if successful.\n @return cl_error_t   CL_ENULLARG null arguments were provided."]
    pub fn cl_engine_free(engine: *mut cl_engine) -> cl_error_t;
}
#[doc = " @brief Pre-cache callback.\n\n Called for each processed file (both the entry level - AKA 'outer' - file and\n inner files - those generated when processing archive and container files), before\n the actual scanning takes place.\n\n @param fd        File descriptor which is about to be scanned.\n @param type      File type detected via magic - i.e. NOT on the fly - (e.g. \"CL_TYPE_MSEXE\").\n @param context   Opaque application provided data.\n @return          CL_CLEAN = File is scanned.\n @return          CL_BREAK = Allowed by callback - file is skipped and marked as clean.\n @return          CL_VIRUS = Blocked by callback - file is skipped and marked as infected."]
pub type clcb_pre_cache = ::std::option::Option<
    unsafe extern "C" fn(
        fd: ::std::os::raw::c_int,
        type_: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t,
>;
extern "C" {
    #[doc = " @brief Set a custom pre-cache callback function.\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine    The initialized scanning engine.\n @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_pre_cache(engine: *mut cl_engine, callback: clcb_pre_cache);
}
#[doc = " @brief File inspection callback.\n\n DISCLAIMER: This interface is to be considered unstable while we continue to evaluate it.\n We may change this interface in the future.\n\n Called for each NEW file (inner and outer).\n Provides capability to record embedded file information during a scan.\n\n @param fd                  Current file descriptor which is about to be scanned.\n @param type                Current file type detected via magic - i.e. NOT on the fly - (e.g. \"CL_TYPE_MSEXE\").\n @param ancestors           An array of ancestors filenames of size `recursion_level`. filenames may be NULL.\n @param parent_file_size    Parent file size.\n @param file_name           Current file name, or NULL if the file does not have a name or ClamAV failed to record the name.\n @param file_size           Current file size.\n @param file_buffer         Current file buffer pointer.\n @param recursion_level     Recursion level / depth of the current file.\n @param layer_attributes    See LAYER_ATTRIBUTES_* flags.\n @param context             Opaque application provided data.\n @return                    CL_CLEAN = File is scanned.\n @return                    CL_BREAK = Whitelisted by callback - file is skipped and marked as clean.\n @return                    CL_VIRUS = Blacklisted by callback - file is skipped and marked as infected."]
pub type clcb_file_inspection = ::std::option::Option<
    unsafe extern "C" fn(
        fd: ::std::os::raw::c_int,
        type_: *const ::std::os::raw::c_char,
        ancestors: *mut *const ::std::os::raw::c_char,
        parent_file_size: usize,
        file_name: *const ::std::os::raw::c_char,
        file_size: usize,
        file_buffer: *const ::std::os::raw::c_char,
        recursion_level: u32,
        layer_attributes: u32,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t,
>;
extern "C" {
    #[doc = " @brief Set a custom file inspection callback function.\n\n DISCLAIMER: This interface is to be considered unstable while we continue to evaluate it.\n We may change this interface in the future.\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine    The initialized scanning engine.\n @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_file_inspection(
        engine: *mut cl_engine,
        callback: clcb_file_inspection,
    );
}
#[doc = " @brief Pre-scan callback.\n\n Called for each NEW file (inner and outer) before the scanning takes place. This is\n roughly the same as clcb_before_cache, but it is affected by clean file caching.\n This means that it won't be called if a clean cached file (inner or outer) is\n scanned a second time.\n\n @param fd        File descriptor which is about to be scanned.\n @param type      File type detected via magic - i.e. NOT on the fly - (e.g. \"CL_TYPE_MSEXE\").\n @param context   Opaque application provided data.\n @return          CL_CLEAN = File is scanned.\n @return          CL_BREAK = Allowed by callback - file is skipped and marked as clean.\n @return          CL_VIRUS = Blocked by callback - file is skipped and marked as infected."]
pub type clcb_pre_scan = ::std::option::Option<
    unsafe extern "C" fn(
        fd: ::std::os::raw::c_int,
        type_: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t,
>;
extern "C" {
    #[doc = " @brief Set a custom pre-scan callback function.\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine    The initialized scanning engine.\n @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_pre_scan(engine: *mut cl_engine, callback: clcb_pre_scan);
}
#[doc = " @brief Post-scan callback.\n\n Called for each processed file (inner and outer), after the scanning is complete.\n In all-match mode, the virname will be one of the matches, but there is no\n guarantee in which order the matches will occur, thus the final virname may\n be any one of the matches.\n\n @param fd        File descriptor which was scanned.\n @param result    The scan result for the file.\n @param virname   A signature name if there was one or more matches.\n @param context   Opaque application provided data.\n @return          Scan result is not overridden.\n @return          CL_BREAK = Allowed by callback - scan result is set to CL_CLEAN.\n @return          Blocked by callback - scan result is set to CL_VIRUS."]
pub type clcb_post_scan = ::std::option::Option<
    unsafe extern "C" fn(
        fd: ::std::os::raw::c_int,
        result: ::std::os::raw::c_int,
        virname: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t,
>;
extern "C" {
    #[doc = " @brief Set a custom post-scan callback function.\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine    The initialized scanning engine.\n @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_post_scan(engine: *mut cl_engine, callback: clcb_post_scan);
}
#[doc = " @brief Virus-found callback.\n\n Called for each signature match.\n If all-match is enabled, clcb_virus_found() may be called multiple times per\n scan.\n\n In addition, clcb_virus_found() does not have a return value and thus.\n can not be used to ignore the match.\n\n @param fd        File descriptor which was scanned.\n @param virname   Virus name.\n @param context   Opaque application provided data."]
pub type clcb_virus_found = ::std::option::Option<
    unsafe extern "C" fn(
        fd: ::std::os::raw::c_int,
        virname: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @brief Set a custom virus-found callback function.\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine    The initialized scanning engine.\n @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_virus_found(engine: *mut cl_engine, callback: clcb_virus_found);
}
#[doc = " @brief Signature-load callback.\n\n May be used to ignore signatures at database load time.\n\n WARNING: Some signatures (notably ldb, cbc) can be dependent upon other signatures.\n          Failure to preserve dependency chains will result in database loading failure.\n          It is the implementor's responsibility to guarantee consistency.\n\n @param type      The signature type (e.g. \"db\", \"ndb\", \"mdb\", etc.)\n @param name      Signature name.\n @param custom    The signature is official (custom == 0) or custom (custom != 0)\n @param context   Opaque application provided data\n @return          0 to load the current signature.\n @return          Non-0 to skip the current signature."]
pub type clcb_sigload = ::std::option::Option<
    unsafe extern "C" fn(
        type_: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        custom: ::std::os::raw::c_uint,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @brief Set a custom signature-load callback function.\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine    The initialized scanning engine.\n @param callback  The callback function pointer.\n @param context   Opaque application provided data."]
    pub fn cl_engine_set_clcb_sigload(
        engine: *mut cl_engine,
        callback: clcb_sigload,
        context: *mut ::std::os::raw::c_void,
    );
}
impl cl_msg {
    pub const CL_MSG_INFO_VERBOSE: cl_msg = cl_msg(32);
}
impl cl_msg {
    pub const CL_MSG_WARN: cl_msg = cl_msg(64);
}
impl cl_msg {
    pub const CL_MSG_ERROR: cl_msg = cl_msg(128);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct cl_msg(pub ::std::os::raw::c_uint);
#[doc = " @brief Progress callback for sig-load, engine-compile, and engine-free.\n\n Progress is complete when total_items == now_completed.\n\n Note: The callback should return CL_SUCCESS. We reserve the right to have it\n       cancel the operation in the future if you return something else...\n       ... but for now, the return value will be ignored.\n\n @param total_items   Total number of items\n @param now_completed Number of items completed\n @param context       Opaque application provided data\n @return cl_error_t   reserved for future use"]
pub type clcb_progress = ::std::option::Option<
    unsafe extern "C" fn(
        total_items: usize,
        now_completed: usize,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t,
>;
extern "C" {
    #[doc = " @brief Set a progress callback function to be called incrementally during a\n database load.\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine    The initialized scanning engine\n @param callback  The callback function pointer\n @param context   Opaque application provided data"]
    pub fn cl_engine_set_clcb_sigload_progress(
        engine: *mut cl_engine,
        callback: clcb_progress,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Set a progress callback function to be called incrementally during an\n engine compile.\n\n Disclaimer: the number of items for this is a rough estimate of the items that\n tend to take longest to compile and doesn't represent an accurate number of\n things compiled.\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine    The initialized scanning engine\n @param callback  The callback function pointer\n @param context   Opaque application provided data"]
    pub fn cl_engine_set_clcb_engine_compile_progress(
        engine: *mut cl_engine,
        callback: clcb_progress,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Set a progress callback function to be called incrementally during an\n engine free (if the engine is in fact freed).\n\n Disclaimer: the number of items for this is a rough estimate of the items that\n tend to take longest to free and doesn't represent an accurate number of\n things freed.\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine    The initialized scanning engine\n @param callback  The callback function pointer\n @param context   Opaque application provided data"]
    pub fn cl_engine_set_clcb_engine_free_progress(
        engine: *mut cl_engine,
        callback: clcb_progress,
        context: *mut ::std::os::raw::c_void,
    );
}
#[doc = " @brief Logging message callback for info, warning, and error messages.\n\n The specified callback will be called instead of logging to stderr.\n Messages of lower severity than specified are logged as usual.\n\n Callback may be used to silence logging by assigning a do-nothing function.\n Does not affect debug log messages.\n\n Just like with cl_debug() this must be called before going multithreaded.\n Callable before cl_init, if you want to log messages from cl_init() itself.\n\n You can use context of cl_scandesc_callback to convey more information to\n the callback (such as the filename!).\n\n Note: setting a 2nd callbacks overwrites previous, multiple callbacks are not\n supported.\n\n @param severity  Message severity (CL_MSG_INFO_VERBOSE, CL_MSG_WARN, or CL_MSG_ERROR).\n @param fullmsg   The log message including the \"LibClamAV <severity>: \" prefix.\n @param msg       The log message.\n @param context   Opaque application provided data."]
pub type clcb_msg = ::std::option::Option<
    unsafe extern "C" fn(
        severity: cl_msg,
        fullmsg: *const ::std::os::raw::c_char,
        msg: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @brief Set a custom logging message callback function for all of libclamav.\n\n @param callback  The callback function pointer."]
    pub fn cl_set_clcb_msg(callback: clcb_msg);
}
#[doc = " @brief LibClamAV hash stats callback.\n\n Callback that provides the hash of a scanned sample if a signature alerted.\n Provides a mechanism to record detection statistics.\n\n @param fd        File descriptor if available, else -1.\n @param size      Sample size\n @param md5       Sample md5 hash\n @param virname   Signature name that the sample matched against\n @param context   Opaque application provided data"]
pub type clcb_hash = ::std::option::Option<
    unsafe extern "C" fn(
        fd: ::std::os::raw::c_int,
        size: ::std::os::raw::c_ulonglong,
        md5: *const ::std::os::raw::c_uchar,
        virname: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @brief Set a custom hash stats callback function.\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine    The initialized scanning engine.\n @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_hash(engine: *mut cl_engine, callback: clcb_hash);
}
#[doc = " @brief Archive meta matching callback function.\n\n May be used to block archive/container samples based on archive metadata.\n Function is invoked multiple times per archive. Typically once per contained file.\n\n Note: Used by the --archive-verbose clamscan option. Overriding this will alter\n the output from --archive-verbose.\n\n @param container_type    String name of type (CL_TYPE).\n @param fsize_container   Sample size\n @param filename          Filename associated with the data in archive.\n @param fsize_real        Size of file after decompression (according to the archive).\n @param is_encrypted      Boolean non-zero if the contained file is encrypted.\n @param filepos_container File index in container.\n @param context           Opaque application provided data.\n @return                  CL_VIRUS to block (alert on)\n @return                  CL_CLEAN to continue scanning"]
pub type clcb_meta = ::std::option::Option<
    unsafe extern "C" fn(
        container_type: *const ::std::os::raw::c_char,
        fsize_container: ::std::os::raw::c_ulong,
        filename: *const ::std::os::raw::c_char,
        fsize_real: ::std::os::raw::c_ulong,
        is_encrypted: ::std::os::raw::c_int,
        filepos_container: ::std::os::raw::c_uint,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t,
>;
extern "C" {
    #[doc = " @brief Set a custom archive metadata matching callback function.\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine    The initialized scanning engine.\n @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_meta(engine: *mut cl_engine, callback: clcb_meta);
}
#[doc = " @brief File properties callback function.\n\n Invoked after a scan the CL_SCAN_GENERAL_COLLECT_METADATA general scan option\n is enabled and libclamav was built with json support.\n\n @param j_propstr File properties/metadata in a JSON encoded string.\n @param rc        The cl_error_t return code from the scan.\n @param cbdata    Opaque application provided data."]
pub type clcb_file_props = ::std::option::Option<
    unsafe extern "C" fn(
        j_propstr: *const ::std::os::raw::c_char,
        rc: ::std::os::raw::c_int,
        cbdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @brief Set a custom file properties callback function.\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine    The initialized scanning engine.\n @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_file_props(engine: *mut cl_engine, callback: clcb_file_props);
}
extern "C" {
    #[doc = " @brief Set a pointer the caller-defined cbdata structure.\n\n The data must persist at least until `clcb_stats_submit()` is called, or\n `clcb_stats_flush()` is called (optional).\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine The scanning engine.\n @param cbdata The statistics data. Probably a pointer to a malloc'd struct."]
    pub fn cl_engine_set_stats_set_cbdata(
        engine: *mut cl_engine,
        cbdata: *mut ::std::os::raw::c_void,
    );
}
#[doc = " @brief Add sample metadata to the statistics for a sample that matched on a signature.\n\n @param virname   Name of the signature that matched.\n @param md5       Sample hash.\n @param size      Sample size.\n @param sections  PE section data, if applicable.\n @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_add_sample = ::std::option::Option<
    unsafe extern "C" fn(
        virname: *const ::std::os::raw::c_char,
        md5: *const ::std::os::raw::c_uchar,
        size: usize,
        sections: *mut stats_section_t,
        cbdata: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @brief Set a custom callback function to add sample metadata to a statistics report.\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine    The initialized scanning engine.\n @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_stats_add_sample(
        engine: *mut cl_engine,
        callback: clcb_stats_add_sample,
    );
}
#[doc = " @brief Remove a specific sample from the statistics report.\n\n @param virname   Name of the signature that matched.\n @param md5       Sample hash.\n @param size      Sample size.\n @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_remove_sample = ::std::option::Option<
    unsafe extern "C" fn(
        virname: *const ::std::os::raw::c_char,
        md5: *const ::std::os::raw::c_uchar,
        size: usize,
        cbdata: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @brief Set a custom callback function to remove sample metadata from a statistics report.\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine    The initialized scanning engine.\n @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_stats_remove_sample(
        engine: *mut cl_engine,
        callback: clcb_stats_remove_sample,
    );
}
#[doc = " @brief Decrement the hit count listed in the statistics report for a specific sample.\n\n @param virname   Name of the signature that matched.\n @param md5       Sample hash.\n @param size      Sample size.\n @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_decrement_count = ::std::option::Option<
    unsafe extern "C" fn(
        virname: *const ::std::os::raw::c_char,
        md5: *const ::std::os::raw::c_uchar,
        size: usize,
        cbdata: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @brief Set a custom callback function to decrement the hit count listed in the statistics report for a specific sample.\n\n This function may remove the sample from the report if the hit count is decremented to 0.\n\n @param engine    The initialized scanning engine.\n @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_stats_decrement_count(
        engine: *mut cl_engine,
        callback: clcb_stats_decrement_count,
    );
}
#[doc = " @brief Function to submit a statistics report.\n\n @param engine    The initialized scanning engine.\n @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_submit = ::std::option::Option<
    unsafe extern "C" fn(engine: *mut cl_engine, cbdata: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " @brief Set a custom callback function to submit the statistics report.\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine    The initialized scanning engine.\n @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_stats_submit(engine: *mut cl_engine, callback: clcb_stats_submit);
}
#[doc = " @brief Function to flush/free the statistics report data.\n\n @param engine    The initialized scanning engine.\n @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_flush = ::std::option::Option<
    unsafe extern "C" fn(engine: *mut cl_engine, cbdata: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " @brief Set a custom callback function to flush/free the statistics report data.\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine    The initialized scanning engine.\n @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_stats_flush(engine: *mut cl_engine, callback: clcb_stats_flush);
}
#[doc = " @brief Function to get the number of samples listed in the statistics report.\n\n @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_get_num =
    ::std::option::Option<unsafe extern "C" fn(cbdata: *mut ::std::os::raw::c_void) -> usize>;
extern "C" {
    #[doc = " @brief Set a custom callback function to get the number of samples listed in the statistics report.\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine    The initialized scanning engine.\n @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_stats_get_num(engine: *mut cl_engine, callback: clcb_stats_get_num);
}
#[doc = " @brief Function to get the size of memory used to store the statistics report.\n\n @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_get_size =
    ::std::option::Option<unsafe extern "C" fn(cbdata: *mut ::std::os::raw::c_void) -> usize>;
extern "C" {
    #[doc = " @brief Set a custom callback function to get the size of memory used to store the statistics report.\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine    The initialized scanning engine.\n @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_stats_get_size(engine: *mut cl_engine, callback: clcb_stats_get_size);
}
#[doc = " @brief Function to get the machine's unique host ID.\n\n @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_get_hostid = ::std::option::Option<
    unsafe extern "C" fn(cbdata: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_char,
>;
extern "C" {
    #[doc = " @brief Set a custom callback function to get the machine's unique host ID.\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine    The initialized scanning engine.\n @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_stats_get_hostid(
        engine: *mut cl_engine,
        callback: clcb_stats_get_hostid,
    );
}
extern "C" {
    #[doc = " @brief Function enables the built-in statistics reporting feature.\n\n @param engine    The initialized scanning engine."]
    pub fn cl_engine_stats_enable(engine: *mut cl_engine);
}
extern "C" {
    #[doc = " @brief Scan a file, given a file descriptor.\n\n @param desc              File descriptor of an open file. The caller must provide this or the map.\n @param filename          (optional) Filepath of the open file descriptor or file map.\n @param[out] virname      Will be set to a statically allocated (i.e. needs not be freed) signature name if the scan matches against a signature.\n @param[out] scanned      The number of bytes scanned.\n @param engine            The scanning engine.\n @param scanoptions       Scanning options.\n @return cl_error_t       CL_CLEAN, CL_VIRUS, or an error code if an error occurred during the scan."]
    pub fn cl_scandesc(
        desc: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        virname: *mut *const ::std::os::raw::c_char,
        scanned: *mut ::std::os::raw::c_ulong,
        engine: *const cl_engine,
        scanoptions: *mut cl_scan_options,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Scan a file, given a file descriptor.\n\n This callback variant allows the caller to provide a context structure that caller provided callback functions can interpret.\n\n @param desc              File descriptor of an open file. The caller must provide this or the map.\n @param filename          (optional) Filepath of the open file descriptor or file map.\n @param[out] virname      Will be set to a statically allocated (i.e. needs not be freed) signature name if the scan matches against a signature.\n @param[out] scanned      The number of bytes scanned.\n @param engine            The scanning engine.\n @param scanoptions       Scanning options.\n @param[in,out] context   An opaque context structure allowing the caller to record details about the sample being scanned.\n @return cl_error_t       CL_CLEAN, CL_VIRUS, or an error code if an error occurred during the scan."]
    pub fn cl_scandesc_callback(
        desc: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        virname: *mut *const ::std::os::raw::c_char,
        scanned: *mut ::std::os::raw::c_ulong,
        engine: *const cl_engine,
        scanoptions: *mut cl_scan_options,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Scan a file, given a filename.\n\n @param filename          Filepath of the file to be scanned.\n @param[out] virname      Will be set to a statically allocated (i.e. needs not be freed) signature name if the scan matches against a signature.\n @param[out] scanned      The number of bytes scanned.\n @param engine            The scanning engine.\n @param scanoptions       Scanning options.\n @return cl_error_t       CL_CLEAN, CL_VIRUS, or an error code if an error occurred during the scan."]
    pub fn cl_scanfile(
        filename: *const ::std::os::raw::c_char,
        virname: *mut *const ::std::os::raw::c_char,
        scanned: *mut ::std::os::raw::c_ulong,
        engine: *const cl_engine,
        scanoptions: *mut cl_scan_options,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Scan a file, given a filename.\n\n This callback variant allows the caller to provide a context structure that caller provided callback functions can interpret.\n\n @param filename          Filepath of the file to be scanned.\n @param[out] virname      Will be set to a statically allocated (i.e. needs not be freed) signature name if the scan matches against a signature.\n @param[out] scanned      The number of bytes scanned.\n @param engine            The scanning engine.\n @param scanoptions       Scanning options.\n @param[in,out] context   An opaque context structure allowing the caller to record details about the sample being scanned.\n @return cl_error_t       CL_CLEAN, CL_VIRUS, or an error code if an error occurred during the scan."]
    pub fn cl_scanfile_callback(
        filename: *const ::std::os::raw::c_char,
        virname: *mut *const ::std::os::raw::c_char,
        scanned: *mut ::std::os::raw::c_ulong,
        engine: *const cl_engine,
        scanoptions: *mut cl_scan_options,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Load the signature databases found at the path.\n\n @param path          May be a file or directory.\n @param engine        The engine to load the signatures into\n @param[out] signo    The number of signatures loaded\n @param dboptions     Database load bitflag field. See the CL_DB_* defines, above.\n @return cl_error_t"]
    pub fn cl_load(
        path: *const ::std::os::raw::c_char,
        engine: *mut cl_engine,
        signo: *mut ::std::os::raw::c_uint,
        dboptions: ::std::os::raw::c_uint,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Get the default database directory path.\n\n @return const char*"]
    pub fn cl_retdbdir() -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cl_cvd {
    pub time: *mut ::std::os::raw::c_char,
    pub version: ::std::os::raw::c_uint,
    pub sigs: ::std::os::raw::c_uint,
    pub fl: ::std::os::raw::c_uint,
    pub md5: *mut ::std::os::raw::c_char,
    pub dsig: *mut ::std::os::raw::c_char,
    pub builder: *mut ::std::os::raw::c_char,
    pub stime: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cl_cvd() {
    const UNINIT: ::std::mem::MaybeUninit<cl_cvd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cl_cvd>(),
        56usize,
        concat!("Size of: ", stringify!(cl_cvd))
    );
    assert_eq!(
        ::std::mem::align_of::<cl_cvd>(),
        8usize,
        concat!("Alignment of ", stringify!(cl_cvd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_cvd),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_cvd),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigs) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_cvd),
            "::",
            stringify!(sigs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fl) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_cvd),
            "::",
            stringify!(fl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).md5) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_cvd),
            "::",
            stringify!(md5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dsig) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_cvd),
            "::",
            stringify!(dsig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).builder) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_cvd),
            "::",
            stringify!(builder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stime) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_cvd),
            "::",
            stringify!(stime)
        )
    );
}
extern "C" {
    #[doc = " @brief Parse the CVD header.\n\n Buffer length is not an argument, and the check must be done\n by the caller cl_cvdhead().\n\n The returned pointer must be free'd with cl_cvdfree().\n\n @param head              Pointer to the header data buffer.\n @return struct cl_cvd*   Pointer to an allocated CVD header data structure."]
    pub fn cl_cvdparse(head: *const ::std::os::raw::c_char) -> *mut cl_cvd;
}
extern "C" {
    #[doc = " @brief Free a CVD header struct.\n\n @param cvd   Pointer to a CVD header struct."]
    pub fn cl_cvdfree(cvd: *mut cl_cvd);
}
extern "C" {
    #[doc = " @brief Get the Functionality Level (FLEVEL).\n\n @return unsigned int The FLEVEL."]
    pub fn cl_retflevel() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief Get the ClamAV version string.\n\n E.g. clamav-0.100.0-beta\n\n @return const char* The version string."]
    pub fn cl_retver() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cl_strerror(clerror: cl_error_t) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cl_fmap {
    _unused: [u8; 0],
}
pub type cl_fmap_t = cl_fmap;
#[doc = " @brief Read callback function type.\n\n A callback function pointer type for reading data from a cl_fmap_t that uses\n reads data from a handle interface.\n\n Read 'count' bytes starting at 'offset' into the buffer 'buf'\n\n Thread safety: It is guaranteed that only one callback is executing for a\n specific handle at any time, but there might be multiple callbacks executing\n for different handle at the same time.\n\n @param handle    The handle passed to cl_fmap_open_handle, its meaning is up\n                  to the callback's implementation\n @param buf       A buffer to read data into, must be at least offset + count\n                  bytes in size.\n @param count     The number of bytes to read.\n @param offset    The offset into buf to read the data to. If successful,\n                  the number of bytes actually read is returned. Upon reading\n                  end-of-file, zero is returned. Otherwise, a -1 is returned\n                  and the global variable errno is set to indicate the error."]
pub type clcb_pread = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut ::std::os::raw::c_void,
        buf: *mut ::std::os::raw::c_void,
        count: usize,
        offset: off_t,
    ) -> off_t,
>;
extern "C" {
    #[doc = " @brief Open a map given a handle.\n\n Open a map for scanning custom data accessed by a handle and pread (lseek +\n read)-like interface. For example a file descriptor or a WIN32 HANDLE.\n By default fmap will use aging to discard old data, unless you tell it not\n to.\n\n The handle will be passed to the callback each time.\n\n @param handle        A handle that may be accessed using lseek + read.\n @param offset        Initial offset to start scanning.\n @param len           Length of the data from the start (not the offset).\n @param pread_cb      A callback function to read data from the handle.\n @param use_aging     Set to a non-zero value to enable aging.\n @return cl_fmap_t*   A map representing the handle interface."]
    pub fn cl_fmap_open_handle(
        handle: *mut ::std::os::raw::c_void,
        offset: usize,
        len: usize,
        pread_cb: clcb_pread,
        use_aging: ::std::os::raw::c_int,
    ) -> *mut cl_fmap_t;
}
extern "C" {
    #[doc = " @brief Open a map given a buffer.\n\n Open a map for scanning custom data, where the data is already in memory,\n either in the form of a buffer, a memory mapped file, etc.\n Note that the memory [start, start+len) must be the _entire_ file,\n you can't give it parts of a file and expect detection to work.\n\n @param start         Pointer to a buffer of data.\n @param len           Length in bytes of the data.\n @return cl_fmap_t*   A map representing the buffer."]
    pub fn cl_fmap_open_memory(start: *const ::std::os::raw::c_void, len: usize) -> *mut cl_fmap_t;
}
extern "C" {
    #[doc = " @brief Releases resources associated with the map.\n\n You should release any resources you hold only after (handles, maps) calling\n this function.\n\n @param map           Map to be closed."]
    pub fn cl_fmap_close(arg1: *mut cl_fmap_t);
}
extern "C" {
    #[doc = " @brief Scan custom data.\n\n @param map           Buffer to be scanned, in form of a cl_fmap_t.\n @param filename      Name of data origin. Does not need to be an actual\n                      file on disk. May be NULL if a name is not available.\n @param[out] virname  Pointer to receive the signature match name name if a\n                      signature matched.\n @param[out] scanned  Number of bytes scanned.\n @param engine        The scanning engine.\n @param scanoptions   The scanning options struct.\n @param context       An application-defined context struct, opaque to\n                      libclamav. May be used within your callback functions.\n @return cl_error_t   CL_CLEAN if no signature matched. CL_VIRUS if a\n                      signature matched. Another CL_E* error code if an\n                      error occurred."]
    pub fn cl_scanmap_callback(
        map: *mut cl_fmap_t,
        filename: *const ::std::os::raw::c_char,
        virname: *mut *const ::std::os::raw::c_char,
        scanned: *mut ::std::os::raw::c_ulong,
        engine: *const cl_engine,
        scanoptions: *mut cl_scan_options,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t;
}
